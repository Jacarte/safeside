# char secret(void* heap, int num) {
#     char a[] = { 'S', 'e', 'c', 'r', 'e', 't', '\0'};
#     return a[num];
# }

# secret(void*, int):
#  mov    eax,0x7465
#  movsxd rsi,esi
#  mov    BYTE PTR [rsp-0x1],0x0
#  mov    DWORD PTR [rsp-0x7],0x72636553
#  mov    WORD PTR [rsp-0x3],ax
#  movzx  eax,BYTE PTR [rsp+rsi*1-0x7]
#  ret

set pagination off

set $indirectCallAddr = (char*) &'guest_func__Z12callIndirectPPFciEPb'

# wait for instruction that computes the address of the indirect function table length object
set $indirectCallLenInstAddr = $indirectCallAddr + 48
tb *$indirectCallLenInstAddr
c

## Hack --- disable bounds check for testing
## p *($indirectCallAddr + 57)=0x90
## p *($indirectCallAddr + 58)=0x90

# Save the table length object address
set $indirectCallLenAddr = (uint64_t)$rdx + 0x8

# wait for instruction that computes the indirect function table rows
set $indirectCallSlotInstAddr = $indirectCallAddr + 70
tb *$indirectCallSlotInstAddr
c

# patch in this function at the expected OOB target
set $target =  $rdx + (((uint64_t)0x0001000) << 4)
set $page = $target & 0xfffffffffffff000
set $mappedslot = (char*) mmap($page, 4096,  0x1 | 0x2 | 0x4, 0x20 | 0x02 | 0x10, -1, 0)
print *(uint64_t*) $target = 2
set $func_loc = 0x15678000
print *(uint64_t*) ($target+8) = $func_loc

set $mapped = (char*) mmap($func_loc, 4096,  0x1 | 0x2 | 0x4, 0x20 | 0x02 | 0x10, -1, 0)

print *($func_loc + 0)  = 0xb8
print *($func_loc + 1)  = 0x65
print *($func_loc + 2)  = 0x74
print *($func_loc + 3)  = 0x00
print *($func_loc + 4)  = 0x00
print *($func_loc + 5)  = 0x48
print *($func_loc + 6)  = 0x63
print *($func_loc + 7)  = 0xf6
print *($func_loc + 8)  = 0xc7
print *($func_loc + 9)  = 0x44
print *($func_loc + 10) = 0x24
print *($func_loc + 11) = 0xf9
print *($func_loc + 12) = 0x53
print *($func_loc + 13) = 0x65
print *($func_loc + 14) = 0x63
print *($func_loc + 15) = 0x72
print *($func_loc + 16) = 0x66
print *($func_loc + 17) = 0x89
print *($func_loc + 18) = 0x44
print *($func_loc + 19) = 0x24
print *($func_loc + 20) = 0xfd
print *($func_loc + 21) = 0xc6
print *($func_loc + 22) = 0x44
print *($func_loc + 23) = 0x24
print *($func_loc + 24) = 0xff
print *($func_loc + 25) = 0x00
print *($func_loc + 26) = 0x0f
print *($func_loc + 27) = 0xb6
print *($func_loc + 28) = 0x44
print *($func_loc + 29) = 0x34
print *($func_loc + 30) = 0xf9
print *($func_loc + 31) = 0xc3

# patch the clflush of host tables
# sanity check
set $trainleakaddr = (char*) &'guest_func__Z29flush_function_table_len_addrv'
set $trainleakaddr1 = (uint64_t*)($trainleakaddr + 4 + 2)
set $trainleakaddr2 = (uint64_t*)($trainleakaddr + 14 + 2)

if *$trainleakaddr1 != 0x1234567890abcde
print "!!!!!!! Error performing patch 1!!!!!!!"
end

print *$trainleakaddr1 = $indirectCallLenAddr

if *$trainleakaddr2 != 0x1234567890abce6
print "!!!!!!! Error performing patch 2!!!!!!!"
end

print *$trainleakaddr2 = $indirectCallLenAddr + 8
c
